"use strict";(self.webpackChunknancy_docs=self.webpackChunknancy_docs||[]).push([[5309],{3473:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tutorials/optimizations/parallelism","title":"Parallelism","description":"The algorithms implemented in Nancy often comprise on a single operation to be done, independently, on a large set of elements.","source":"@site/docs/tutorials/optimizations/parallelism.md","sourceDirName":"tutorials/optimizations","slug":"/tutorials/optimizations/parallelism","permalink":"/nancy/docs/tutorials/optimizations/parallelism","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"hide_title":true,"sidebar_position":3,"title":"Parallelism"},"sidebar":"tutorialSidebar","previous":{"title":"Generators","permalink":"/nancy/docs/tutorials/optimizations/generators"},"next":{"title":"Representation minimization","permalink":"/nancy/docs/tutorials/optimizations/representation-minimization"}}');var o=n(4848),a=n(8453);const s={hide_title:!0,sidebar_position:3,title:"Parallelism"},r="Parallelism",l={},c=[{value:"Note on the effective speed-ups",id:"note-on-the-effective-speed-ups",level:2}];function h(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"parallelism",children:"Parallelism"})}),"\n",(0,o.jsxs)(t.p,{children:["The algorithms implemented in Nancy often comprise on a single operation to be done, independently, on a large set of elements.\r\nFor example, the (min,+) convolution consists of a) a large set of element-element convolutions, b) grouping the results of the convolutions by intervals of overlap, c) computing the by-interval lower envelopes.\r\nThese operations, being independent (as Nancy is also implemented with ",(0,o.jsx)(t.em,{children:"immutable"})," objects), can be easily parallelized."]}),"\n",(0,o.jsxs)(t.p,{children:["The C# language and .NET Runtime make this easy to do with little code changes, mainly through the ",(0,o.jsx)(t.code,{children:"AsParallel()"})," method that makes a ",(0,o.jsx)(t.code,{children:"LINQ"})," query run on all the cores available, rather than a single one."]}),"\n",(0,o.jsx)(t.h2,{id:"note-on-the-effective-speed-ups",children:"Note on the effective speed-ups"}),"\n",(0,o.jsx)(t.p,{children:"It is often the case in the research community that one is asked about the effectiveness of the parallelization of an algorithm, in particular whether the speedup is close to the number of cores or not.\r\nWe wish to dispel this notion by arguing that it is an anti-practical point of view."}),"\n",(0,o.jsxs)(t.p,{children:["In fact, it would be meaningful to wonder if an algorithm could gain significant performance improvements by augmenting its degree of parallelism ",(0,o.jsx)(t.em,{children:"if we were making a choice on the amount of cores to have"}),".\r\nOn the contrary, in most practical use cases, we are not making this choice."]}),"\n",(0,o.jsx)(t.p,{children:"In most systems nowadays, as we are used to running advanced operating systems with heavy multiprocessing and interactivity, all but the lowest price options will feature 8 cores, with many common options featuring 12 or 16.\r\nFurthermore, the amount of cores usually grows in tandem with the processing power of the single core, such that the number of cores is rarely a direct factor on the price-to-performance evaluation."}),"\n",(0,o.jsxs)(t.p,{children:["Thus, since we already have multicore systems and their parallel processing power available, the question should be ",(0,o.jsx)(t.em,{children:"is this software capable of exploiting the resources available on the system to complete faster, rather than sit on 15/16 of its processing power?"})," In the case of Nancy, the answer is yes."]}),"\n",(0,o.jsx)(t.p,{children:"That is not to say that the approach is perfect - many heuristics are employed to decide if an operation would benefit from going parallel or not, and such heuristics may fail or require adjustments on a different architecture.\r\nHowever, even if only a 10x speedup were obtained on a 16 core machine, that is still six minutes instead of an hour."})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);