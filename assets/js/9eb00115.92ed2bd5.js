"use strict";(self.webpackChunknancy_docs=self.webpackChunknancy_docs||[]).push([[4792],{8453:(e,l,n)=>{n.d(l,{R:()=>o,x:()=>i});var s=n(6540);const r={},t=s.createContext(r);function o(e){const l=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(l):{...l,...e}}),[l,e])}function i(e){let l;return l=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:l},e.children)}},9055:(e,l,n)=>{n.r(l),n.d(l,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings","title":"ComputationSettings","description":"Used to specify the computation settings of most operations.","source":"@site/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings.md","sourceDirName":"nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra","slug":"/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings","permalink":"/nancy/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true,"title":"ComputationSettings"},"sidebar":"docsSidebar","previous":{"title":"Element","permalink":"/nancy/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/Element"},"next":{"title":"CurveExtensions","permalink":"/nancy/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/CurveExtensions"}}');var r=n(4848),t=n(8453);const o={hide_title:!0,title:"ComputationSettings"},i="ComputationSettings",a={},c=[{value:"Properties",id:"properties",level:2},{value:"<strong>UseParallelism</strong>",id:"useparallelism",level:3},{value:"Property Value",id:"property-value",level:4},{value:"<strong>UseParallelLowerEnvelope</strong>",id:"useparallellowerenvelope",level:3},{value:"Property Value",id:"property-value-1",level:4},{value:"<strong>UseParallelUpperEnvelope</strong>",id:"useparallelupperenvelope",level:3},{value:"Property Value",id:"property-value-2",level:4},{value:"<strong>UseParallelListAddition</strong>",id:"useparallellistaddition",level:3},{value:"Property Value",id:"property-value-3",level:4},{value:"<strong>UseParallelListMinimum</strong>",id:"useparallellistminimum",level:3},{value:"Property Value",id:"property-value-4",level:4},{value:"<strong>UseParallelListMaximum</strong>",id:"useparallellistmaximum",level:3},{value:"Property Value",id:"property-value-5",level:4},{value:"<strong>UseParallelListConvolution</strong>",id:"useparallellistconvolution",level:3},{value:"Property Value",id:"property-value-6",level:4},{value:"<strong>UseParallelListLowerEnvelope</strong>",id:"useparallellistlowerenvelope",level:3},{value:"Property Value",id:"property-value-7",level:4},{value:"<strong>UseParallelListUpperEnvelope</strong>",id:"useparallellistupperenvelope",level:3},{value:"Property Value",id:"property-value-8",level:4},{value:"<strong>UseParallelConvolution</strong>",id:"useparallelconvolution",level:3},{value:"Property Value",id:"property-value-9",level:4},{value:"<strong>ConvolutionParallelizationThreshold</strong>",id:"convolutionparallelizationthreshold",level:3},{value:"Property Value",id:"property-value-10",level:4},{value:"<strong>UseConvolutionPartitioning</strong>",id:"useconvolutionpartitioning",level:3},{value:"Property Value",id:"property-value-11",level:4},{value:"<strong>ConvolutionPartitioningThreshold</strong>",id:"convolutionpartitioningthreshold",level:3},{value:"Property Value",id:"property-value-12",level:4},{value:"<strong>UseParallelComputeIntervals</strong>",id:"useparallelcomputeintervals",level:3},{value:"Property Value",id:"property-value-13",level:4},{value:"<strong>ParallelComputeIntervalsThreshold</strong>",id:"parallelcomputeintervalsthreshold",level:3},{value:"Property Value",id:"property-value-14",level:4},{value:"<strong>UseParallelInsertionComputeIntervals</strong>",id:"useparallelinsertioncomputeintervals",level:3},{value:"Property Value",id:"property-value-15",level:4},{value:"<strong>UseParallelDeconvolution</strong>",id:"useparalleldeconvolution",level:3},{value:"Property Value",id:"property-value-16",level:4},{value:"<strong>DeconvolutionParallelizationThreshold</strong>",id:"deconvolutionparallelizationthreshold",level:3},{value:"Property Value",id:"property-value-17",level:4},{value:"<strong>UseParallelExtend</strong>",id:"useparallelextend",level:3},{value:"Property Value",id:"property-value-18",level:4},{value:"<strong>UseParallelComputeExtensionSequences</strong>",id:"useparallelcomputeextensionsequences",level:3},{value:"Property Value",id:"property-value-19",level:4},{value:"<strong>UseParallelSortElements</strong>",id:"useparallelsortelements",level:3},{value:"Property Value",id:"property-value-20",level:4},{value:"<strong>SinglePassConvolution</strong>",id:"singlepassconvolution",level:3},{value:"Property Value",id:"property-value-21",level:4},{value:"<strong>UseRepresentationMinimization</strong>",id:"userepresentationminimization",level:3},{value:"Property Value",id:"property-value-22",level:4},{value:"<strong>UseSubAdditiveConvolutionOptimizations</strong>",id:"usesubadditiveconvolutionoptimizations",level:3},{value:"Property Value",id:"property-value-23",level:4},{value:"Constructors",id:"constructors",level:2},{value:"<strong>ComputationSettings()</strong>",id:"computationsettings-1",level:3},{value:"Methods",id:"methods",level:2},{value:"<strong>Default()</strong>",id:"default",level:3},{value:"Returns",id:"returns",level:4},{value:"<strong>ToString()</strong>",id:"tostring",level:3},{value:"Returns",id:"returns-1",level:4},{value:"<strong>GetHashCode()</strong>",id:"gethashcode",level:3},{value:"Returns",id:"returns-2",level:4},{value:"<strong>Equals(Object)</strong>",id:"equalsobject",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns-3",level:4},{value:"<strong>Equals(ComputationSettings)</strong>",id:"equalscomputationsettings",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-4",level:4},{value:"<strong>&lt;Clone&gt;$()</strong>",id:"clone",level:3},{value:"Returns",id:"returns-5",level:4}];function p(e){const l={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(l.header,{children:(0,r.jsx)(l.h1,{id:"computationsettings",children:"ComputationSettings"})}),"\n",(0,r.jsx)(l.p,{children:"Used to specify the computation settings of most operations.\r\nIf left unspecified, the default settings are used."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public class ComputationSettings : System.IEquatable<ComputationSettings>\n"})}),"\n",(0,r.jsxs)(l.p,{children:["Inheritance ",(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.object",children:"Object"})," \u2192 ",(0,r.jsx)(l.a,{href:"/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",children:"ComputationSettings"}),(0,r.jsx)("br",{}),"\r\nImplements ",(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.iequatable-1",children:"IEquatable<ComputationSettings>"})]}),"\n",(0,r.jsx)(l.h2,{id:"properties",children:"Properties"}),"\n",(0,r.jsx)(l.h3,{id:"useparallelism",children:(0,r.jsx)(l.strong,{children:"UseParallelism"})}),"\n",(0,r.jsx)(l.p,{children:"Catch-all property.\r\nGet: is true if any parallelism is enabled.\r\nSet: sets all parallelism options at once, to the given value."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelism { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellowerenvelope",children:(0,r.jsx)(l.strong,{children:"UseParallelLowerEnvelope"})}),"\n",(0,r.jsx)(l.p,{children:"If true, long sequence minimums are processed in parallel."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelLowerEnvelope { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-1",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelupperenvelope",children:(0,r.jsx)(l.strong,{children:"UseParallelUpperEnvelope"})}),"\n",(0,r.jsx)(l.p,{children:"If true, long sequence maximums are processed in parallel."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelUpperEnvelope { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-2",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellistaddition",children:(0,r.jsx)(l.strong,{children:"UseParallelListAddition"})}),"\n",(0,r.jsx)(l.p,{children:"If true, additions of long lists of curves are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelListAddition { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-3",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellistminimum",children:(0,r.jsx)(l.strong,{children:"UseParallelListMinimum"})}),"\n",(0,r.jsx)(l.p,{children:"If true, minimums of long lists of curves are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelListMinimum { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-4",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellistmaximum",children:(0,r.jsx)(l.strong,{children:"UseParallelListMaximum"})}),"\n",(0,r.jsx)(l.p,{children:"If true, maximums of long lists of curves are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelListMaximum { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-5",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellistconvolution",children:(0,r.jsx)(l.strong,{children:"UseParallelListConvolution"})}),"\n",(0,r.jsx)(l.p,{children:"If true, convolutions of long lists of curves are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelListConvolution { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-6",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellistlowerenvelope",children:(0,r.jsx)(l.strong,{children:"UseParallelListLowerEnvelope"})}),"\n",(0,r.jsx)(l.p,{children:"If true, minimums of long lists of curves are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelListLowerEnvelope { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-7",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallellistupperenvelope",children:(0,r.jsx)(l.strong,{children:"UseParallelListUpperEnvelope"})}),"\n",(0,r.jsx)(l.p,{children:"If true, maximums of long lists of curves are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelListUpperEnvelope { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-8",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelconvolution",children:(0,r.jsx)(l.strong,{children:"UseParallelConvolution"})}),"\n",(0,r.jsx)(l.p,{children:"If true, long sequence convolutions are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelConvolution { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-9",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"convolutionparallelizationthreshold",children:(0,r.jsx)(l.strong,{children:"ConvolutionParallelizationThreshold"})}),"\n",(0,r.jsx)(l.p,{children:"Convolution parallelization is done if the number of element convolutions is above this threshold."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public int ConvolutionParallelizationThreshold { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-10",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32",children:"Int32"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useconvolutionpartitioning",children:(0,r.jsx)(l.strong,{children:"UseConvolutionPartitioning"})}),"\n",(0,r.jsx)(l.p,{children:"If true, long sequence convolutions are partitioned into smaller ones to reduce memory impact"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseConvolutionPartitioning { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-11",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"convolutionpartitioningthreshold",children:(0,r.jsx)(l.strong,{children:"ConvolutionPartitioningThreshold"})}),"\n",(0,r.jsx)(l.p,{children:"Convolution partitioning is done if the number of element convolutions is above this threshold."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public int ConvolutionPartitioningThreshold { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-12",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32",children:"Int32"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelcomputeintervals",children:(0,r.jsx)(l.strong,{children:"UseParallelComputeIntervals"})}),"\n",(0,r.jsx)(l.p,{children:"If true, Interval.ComputeIntervals may use parallel implementation"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelComputeIntervals { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-13",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"parallelcomputeintervalsthreshold",children:(0,r.jsx)(l.strong,{children:"ParallelComputeIntervalsThreshold"})}),"\n",(0,r.jsx)(l.p,{children:"Interval.ComputeIntervals is done with parallel implementation if the number of elements is above this threshold."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public int ParallelComputeIntervalsThreshold { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-14",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32",children:"Int32"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelinsertioncomputeintervals",children:(0,r.jsx)(l.strong,{children:"UseParallelInsertionComputeIntervals"})}),"\n",(0,r.jsx)(l.p,{children:"In parallel Interval.ComputeIntervals, do element-in-interval insertion in parallel too."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelInsertionComputeIntervals { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-15",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparalleldeconvolution",children:(0,r.jsx)(l.strong,{children:"UseParallelDeconvolution"})}),"\n",(0,r.jsx)(l.p,{children:"If true, long sequence convolutions are processed in parallel"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelDeconvolution { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-16",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"deconvolutionparallelizationthreshold",children:(0,r.jsx)(l.strong,{children:"DeconvolutionParallelizationThreshold"})}),"\n",(0,r.jsx)(l.p,{children:"Deconvolution parallelization is done if the number of element deconvolutions is above this threshold."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public int DeconvolutionParallelizationThreshold { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-17",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32",children:"Int32"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelextend",children:(0,r.jsx)(l.strong,{children:"UseParallelExtend"})}),"\n",(0,r.jsx)(l.p,{children:"In Curve.Extend, compute extension sequences in parallel."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelExtend { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-18",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelcomputeextensionsequences",children:(0,r.jsx)(l.strong,{children:"UseParallelComputeExtensionSequences"})}),"\n",(0,r.jsx)(l.p,{children:"In Curve.ComputeExtensionSequences, compute elements of the sequence in parallel."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelComputeExtensionSequences { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-19",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"useparallelsortelements",children:(0,r.jsx)(l.strong,{children:"UseParallelSortElements"})}),"\n",(0,r.jsx)(l.p,{children:"In Extensions.SortElements, sort the elements in parallel."}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseParallelSortElements { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-20",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"singlepassconvolution",children:(0,r.jsx)(l.strong,{children:"SinglePassConvolution"})}),"\n",(0,r.jsx)(l.p,{children:"If true, when two Curves have the same slope the convolution is done in a single pass"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool SinglePassConvolution { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-21",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"userepresentationminimization",children:(0,r.jsx)(l.strong,{children:"UseRepresentationMinimization"})}),"\n",(0,r.jsx)(l.p,{children:"If set, results of each operation are optimized towards minimal representation"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseRepresentationMinimization { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-22",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"usesubadditiveconvolutionoptimizations",children:(0,r.jsx)(l.strong,{children:"UseSubAdditiveConvolutionOptimizations"})}),"\n",(0,r.jsx)(l.p,{children:"If set, convolutions between sub-additive curves are optimized"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool UseSubAdditiveConvolutionOptimizations { get; set; }\n"})}),"\n",(0,r.jsx)(l.h4,{id:"property-value-23",children:"Property Value"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h2,{id:"constructors",children:"Constructors"}),"\n",(0,r.jsx)(l.h3,{id:"computationsettings-1",children:(0,r.jsx)(l.strong,{children:"ComputationSettings()"})}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public ComputationSettings()\n"})}),"\n",(0,r.jsx)(l.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(l.h3,{id:"default",children:(0,r.jsx)(l.strong,{children:"Default()"})}),"\n",(0,r.jsx)(l.p,{children:"Default settings"}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public static ComputationSettings Default()\n"})}),"\n",(0,r.jsx)(l.h4,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",children:"ComputationSettings"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"tostring",children:(0,r.jsx)(l.strong,{children:"ToString()"})}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public string ToString()\n"})}),"\n",(0,r.jsx)(l.h4,{id:"returns-1",children:"Returns"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.string",children:"String"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"gethashcode",children:(0,r.jsx)(l.strong,{children:"GetHashCode()"})}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public int GetHashCode()\n"})}),"\n",(0,r.jsx)(l.h4,{id:"returns-2",children:"Returns"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32",children:"Int32"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"equalsobject",children:(0,r.jsx)(l.strong,{children:"Equals(Object)"})}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool Equals(object obj)\n"})}),"\n",(0,r.jsx)(l.h4,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.code,{children:"obj"})," ",(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.object",children:"Object"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h4,{id:"returns-3",children:"Returns"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"equalscomputationsettings",children:(0,r.jsx)(l.strong,{children:"Equals(ComputationSettings)"})}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public bool Equals(ComputationSettings other)\n"})}),"\n",(0,r.jsx)(l.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.code,{children:"other"})," ",(0,r.jsx)(l.a,{href:"/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",children:"ComputationSettings"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h4,{id:"returns-4",children:"Returns"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean",children:"Boolean"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.h3,{id:"clone",children:(0,r.jsx)(l.strong,{children:"<Clone>$()"})}),"\n",(0,r.jsx)(l.pre,{children:(0,r.jsx)(l.code,{className:"language-csharp",children:"public ComputationSettings <Clone>$()\n"})}),"\n",(0,r.jsx)(l.h4,{id:"returns-5",children:"Returns"}),"\n",(0,r.jsxs)(l.p,{children:[(0,r.jsx)(l.a,{href:"/docs/nancy/Unipi.Nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",children:"ComputationSettings"}),(0,r.jsx)("br",{})]})]})}function d(e={}){const{wrapper:l}={...(0,t.R)(),...e.components};return l?(0,r.jsx)(l,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);