"use strict";(self.webpackChunknancy_docs=self.webpackChunknancy_docs||[]).push([[6381],{3019:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorials/optimizations/isospeed-convolutions","title":"Isospeed convolutions","description":"In [PLSK11] and [Lie17], it was observed that one can use pseudoinverses to switch from a (min,+) computation to a (max,+) one, and back (under some non-restrictive hypotheses).","source":"@site/docs/tutorials/optimizations/isospeed-convolutions.mdx","sourceDirName":"tutorials/optimizations","slug":"/tutorials/optimizations/isospeed-convolutions","permalink":"/nancy/docs/tutorials/optimizations/isospeed-convolutions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"hide_title":true,"sidebar_position":6,"title":"Isospeed convolutions"},"sidebar":"tutorialSidebar","previous":{"title":"Subadditive convolutions","permalink":"/nancy/docs/tutorials/optimizations/subadditive-convolutions"},"next":{"title":"Tuning Performance","permalink":"/nancy/docs/tutorials/optimizations/tuning-performance"}}');var s=n(4848),i=n(8453),r=n(9030);const a={hide_title:!0,sidebar_position:6,title:"Isospeed convolutions"},c="Isospeed convolutions",d={},l=[];function p(e){const o={em:"em",h1:"h1",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"isospeed-convolutions",children:"Isospeed convolutions"})}),"\n",(0,s.jsxs)(o.p,{children:["In ",(0,s.jsx)("a",{href:"/docs/tutorials/references#PLSK11",children:"[PLSK11]"})," and ",(0,s.jsx)("a",{href:"/docs/tutorials/references#Lie17",children:"[Lie17]"}),", it was observed that one can use pseudoinverses to switch from a (min,+) computation to a (max,+) one, and back (under some non-restrictive hypotheses).\r\nFurthermore, doing so would often result in significant performance improvements."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:(0,r.Ay)("/img/isospeed-convolution/isomorphism.png"),style:{maxWidth:"min(40rem, 100%)"}}),(0,s.jsx)("figcaption",{children:"The isomorphism between (min,+) and (max,+) convolution."})]}),"\n",(0,s.jsxs)(o.p,{children:["In ",(0,s.jsx)("a",{href:"/docs/tutorials/references#ZNS23a",children:"[ZNS23a]"})," we explored this further, finding the main properties that cause these performance and devising a new algorithm, ",(0,s.jsx)(o.em,{children:"Isospeed"}),", which exploits them to gain significant performance improvements over ",(0,s.jsx)(o.em,{children:"both"})," the state-of-art (min,+) and (max,+) convolution algorithms."]}),"\n",(0,s.jsx)(o.p,{children:"These improvements are implemented in Nancy transparently to the user, so that no action or configuration in necessary to get these improvements."}),"\n",(0,s.jsxs)(o.p,{children:["For more details, checkout the paper ",(0,s.jsx)("a",{href:"/docs/tutorials/references#ZNS23a",children:"[ZNS23a]"})," or ",(0,s.jsx)("a",{href:"/docs/tutorials/references#Zippo23",children:"[Zippo23]"}),", Chapter 14."]})]})}function u(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>r,x:()=>a});var t=n(6540);const s={},i=t.createContext(s);function r(e){const o=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);