"use strict";(self.webpackChunknancy_docs=self.webpackChunknancy_docs||[]).push([[7768],{7994:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"tutorials/optimizations/generators","title":"Generators","description":"Generators are a programming structure that allows to iterate over a large number of items without the need to store them all at once.","source":"@site/docs/tutorials/optimizations/generators.md","sourceDirName":"tutorials/optimizations","slug":"/tutorials/optimizations/generators","permalink":"/nancy/docs/tutorials/optimizations/generators","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"hide_title":true,"sidebar_position":2,"title":"Generators"},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/nancy/docs/tutorials/optimizations/overview"},"next":{"title":"Parallelism","permalink":"/nancy/docs/tutorials/optimizations/parallelism"}}');var o=n(4848),a=n(8453);const i={hide_title:!0,sidebar_position:2,title:"Generators"},s="Generators",l={},c=[];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"generators",children:"Generators"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Generators"})," are a programming structure that allows to iterate over a large number of items without the need to store them all at once.\r\nFor example, consider this code:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"int[] array = // lots of numbers\r\nforeach(int v in array)\r\n    Console.WriteLine(v);\n"})}),"\n",(0,o.jsx)(t.p,{children:"This code first allocates the entire array, then prints its items one at a time.\r\nThis allocation is a waste of not only memory, but also the computing spent on managing that memory, which could be avoided if each item was allocated right before printing it and then deallocated right away."}),"\n",(0,o.jsxs)(t.p,{children:["Many of the algorithms implemented in Nancy need to work on large numbers of elements, but one at a time.\r\nVia methods such as ",(0,o.jsx)(t.code,{children:"Curve.Cut()"})," and ",(0,o.jsx)(t.code,{children:"Curve.CutAsEnumerable()"}),", the library allows for controlling when the elements are allocated without changing the code using these elements, leveraging C# support for generators (",(0,o.jsx)(t.code,{children:"yield"}),", ",(0,o.jsx)(t.code,{children:"IEnumerable"}),", ",(0,o.jsx)(t.code,{children:"LINQ"}),", etc.)."]}),"\n",(0,o.jsxs)(t.p,{children:["For a longer introduction to this topic, you can check ",(0,o.jsx)(t.a,{href:"https://flore.unifi.it/handle/2158/1320671",children:"Raffaele Zippo's PhD Thesis"}),", Appendix A."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var r=n(6540);const o={},a=r.createContext(o);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);