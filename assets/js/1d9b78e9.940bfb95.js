"use strict";(self.webpackChunknancy_docs=self.webpackChunknancy_docs||[]).push([[1490],{3905:(e,t,l)=>{l.d(t,{Zo:()=>u,kt:()=>d});var n=l(7294);function a(e,t,l){return t in e?Object.defineProperty(e,t,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[t]=l,e}function o(e,t){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),l.push.apply(l,n)}return l}function r(e){for(var t=1;t<arguments.length;t++){var l=null!=arguments[t]?arguments[t]:{};t%2?o(Object(l),!0).forEach((function(t){a(e,t,l[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):o(Object(l)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(l,t))}))}return e}function s(e,t){if(null==e)return{};var l,n,a=function(e,t){if(null==e)return{};var l,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)l=o[n],t.indexOf(l)>=0||(a[l]=e[l]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)l=o[n],t.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(a[l]=e[l])}return a}var p=n.createContext({}),i=function(e){var t=n.useContext(p),l=t;return e&&(l="function"==typeof e?e(t):r(r({},t),e)),l},u=function(e){var t=i(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var l=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=i(l),d=a,v=m["".concat(p,".").concat(d)]||m[d]||c[d]||o;return l?n.createElement(v,r(r({ref:t},u),{},{components:l})):n.createElement(v,r({ref:t},u))}));function d(e,t){var l=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=l.length,r=new Array(o);r[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var i=2;i<o;i++)r[i]=l[i];return n.createElement.apply(null,r)}return n.createElement.apply(null,l)}m.displayName="MDXCreateElement"},571:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>i});var n=l(7462),a=(l(7294),l(3905));const o={hide_title:!0},r="ComputationSettings",s={unversionedId:"nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",id:"nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",title:"ComputationSettings",description:"Used to specify the computation settings of most operations.",source:"@site/docs/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings.md",sourceDirName:"nancy/Unipi.Nancy.MinPlusAlgebra",slug:"/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",permalink:"/nancy/docs/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0},sidebar:"docsSidebar",previous:{title:"Element",permalink:"/nancy/docs/nancy/Unipi.Nancy.MinPlusAlgebra/Element"},next:{title:"CurveExtensions",permalink:"/nancy/docs/nancy/Unipi.Nancy.MinPlusAlgebra/CurveExtensions"}},p={},i=[{value:"Properties",id:"properties",level:2},{value:"<strong>UseParallelism</strong>",id:"useparallelism",level:3},{value:"Property Value",id:"property-value",level:4},{value:"<strong>UseParallelLowerEnvelope</strong>",id:"useparallellowerenvelope",level:3},{value:"Property Value",id:"property-value-1",level:4},{value:"<strong>UseParallelUpperEnvelope</strong>",id:"useparallelupperenvelope",level:3},{value:"Property Value",id:"property-value-2",level:4},{value:"<strong>UseParallelListAddition</strong>",id:"useparallellistaddition",level:3},{value:"Property Value",id:"property-value-3",level:4},{value:"<strong>UseParallelListMinimum</strong>",id:"useparallellistminimum",level:3},{value:"Property Value",id:"property-value-4",level:4},{value:"<strong>UseParallelListMaximum</strong>",id:"useparallellistmaximum",level:3},{value:"Property Value",id:"property-value-5",level:4},{value:"<strong>UseParallelListConvolution</strong>",id:"useparallellistconvolution",level:3},{value:"Property Value",id:"property-value-6",level:4},{value:"<strong>UseParallelListLowerEnvelope</strong>",id:"useparallellistlowerenvelope",level:3},{value:"Property Value",id:"property-value-7",level:4},{value:"<strong>UseParallelListUpperEnvelope</strong>",id:"useparallellistupperenvelope",level:3},{value:"Property Value",id:"property-value-8",level:4},{value:"<strong>UseParallelConvolution</strong>",id:"useparallelconvolution",level:3},{value:"Property Value",id:"property-value-9",level:4},{value:"<strong>ConvolutionParallelizationThreshold</strong>",id:"convolutionparallelizationthreshold",level:3},{value:"Property Value",id:"property-value-10",level:4},{value:"<strong>UseConvolutionPartitioning</strong>",id:"useconvolutionpartitioning",level:3},{value:"Property Value",id:"property-value-11",level:4},{value:"<strong>ConvolutionPartitioningThreshold</strong>",id:"convolutionpartitioningthreshold",level:3},{value:"Property Value",id:"property-value-12",level:4},{value:"<strong>UseParallelComputeIntervals</strong>",id:"useparallelcomputeintervals",level:3},{value:"Property Value",id:"property-value-13",level:4},{value:"<strong>ParallelComputeIntervalsThreshold</strong>",id:"parallelcomputeintervalsthreshold",level:3},{value:"Property Value",id:"property-value-14",level:4},{value:"<strong>UseParallelInsertionComputeIntervals</strong>",id:"useparallelinsertioncomputeintervals",level:3},{value:"Property Value",id:"property-value-15",level:4},{value:"<strong>UseParallelDeconvolution</strong>",id:"useparalleldeconvolution",level:3},{value:"Property Value",id:"property-value-16",level:4},{value:"<strong>DeconvolutionParallelizationThreshold</strong>",id:"deconvolutionparallelizationthreshold",level:3},{value:"Property Value",id:"property-value-17",level:4},{value:"<strong>UseParallelExtend</strong>",id:"useparallelextend",level:3},{value:"Property Value",id:"property-value-18",level:4},{value:"<strong>UseParallelComputeExtensionSequences</strong>",id:"useparallelcomputeextensionsequences",level:3},{value:"Property Value",id:"property-value-19",level:4},{value:"<strong>UseParallelSortElements</strong>",id:"useparallelsortelements",level:3},{value:"Property Value",id:"property-value-20",level:4},{value:"<strong>SinglePassConvolution</strong>",id:"singlepassconvolution",level:3},{value:"Property Value",id:"property-value-21",level:4},{value:"<strong>UseRepresentationMinimization</strong>",id:"userepresentationminimization",level:3},{value:"Property Value",id:"property-value-22",level:4},{value:"<strong>UseSubAdditiveConvolutionOptimizations</strong>",id:"usesubadditiveconvolutionoptimizations",level:3},{value:"Property Value",id:"property-value-23",level:4},{value:"Constructors",id:"constructors",level:2},{value:"<strong>ComputationSettings()</strong>",id:"computationsettings-1",level:3},{value:"Methods",id:"methods",level:2},{value:"<strong>Default()</strong>",id:"default",level:3},{value:"Returns",id:"returns",level:4},{value:"<strong>ToString()</strong>",id:"tostring",level:3},{value:"Returns",id:"returns-1",level:4},{value:"<strong>GetHashCode()</strong>",id:"gethashcode",level:3},{value:"Returns",id:"returns-2",level:4},{value:"<strong>Equals(Object)</strong>",id:"equalsobject",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns-3",level:4},{value:"<strong>Equals(ComputationSettings)</strong>",id:"equalscomputationsettings",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-4",level:4},{value:"<strong>&lt;Clone&gt;$()</strong>",id:"clone",level:3},{value:"Returns",id:"returns-5",level:4}],u={toc:i};function c(e){let{components:t,...l}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"computationsettings"},"ComputationSettings"),(0,a.kt)("p",null,"Used to specify the computation settings of most operations.\nIf left unspecified, the default settings are used."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public class ComputationSettings : System.IEquatable<ComputationSettings>\n")),(0,a.kt)("p",null,"Inheritance ",(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.object"},"Object")," \u2192 ",(0,a.kt)("a",{parentName:"p",href:"/docs/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings"},"ComputationSettings"),(0,a.kt)("br",null),"\nImplements ",(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.iequatable-1"},"IEquatable","<","ComputationSettings",">")),(0,a.kt)("h2",{id:"properties"},"Properties"),(0,a.kt)("h3",{id:"useparallelism"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelism")),(0,a.kt)("p",null,"Catch-all property.\nGet: is true if any parallelism is enabled.\nSet: sets all parallelism options at once, to the given value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelism { get; set; }\n")),(0,a.kt)("h4",{id:"property-value"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellowerenvelope"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelLowerEnvelope")),(0,a.kt)("p",null,"If true, long sequence minimums are processed in parallel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelLowerEnvelope { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-1"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelupperenvelope"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelUpperEnvelope")),(0,a.kt)("p",null,"If true, long sequence maximums are processed in parallel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelUpperEnvelope { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-2"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellistaddition"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelListAddition")),(0,a.kt)("p",null,"If true, additions of long lists of curves are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelListAddition { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-3"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellistminimum"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelListMinimum")),(0,a.kt)("p",null,"If true, minimums of long lists of curves are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelListMinimum { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-4"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellistmaximum"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelListMaximum")),(0,a.kt)("p",null,"If true, maximums of long lists of curves are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelListMaximum { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-5"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellistconvolution"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelListConvolution")),(0,a.kt)("p",null,"If true, convolutions of long lists of curves are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelListConvolution { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-6"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellistlowerenvelope"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelListLowerEnvelope")),(0,a.kt)("p",null,"If true, minimums of long lists of curves are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelListLowerEnvelope { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-7"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallellistupperenvelope"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelListUpperEnvelope")),(0,a.kt)("p",null,"If true, maximums of long lists of curves are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelListUpperEnvelope { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-8"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelconvolution"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelConvolution")),(0,a.kt)("p",null,"If true, long sequence convolutions are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelConvolution { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-9"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"convolutionparallelizationthreshold"},(0,a.kt)("strong",{parentName:"h3"},"ConvolutionParallelizationThreshold")),(0,a.kt)("p",null,"Convolution parallelization is done if the number of element convolutions is above this threshold."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public int ConvolutionParallelizationThreshold { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-10"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32"},"Int32"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useconvolutionpartitioning"},(0,a.kt)("strong",{parentName:"h3"},"UseConvolutionPartitioning")),(0,a.kt)("p",null,"If true, long sequence convolutions are partitioned into smaller ones to reduce memory impact"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseConvolutionPartitioning { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-11"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"convolutionpartitioningthreshold"},(0,a.kt)("strong",{parentName:"h3"},"ConvolutionPartitioningThreshold")),(0,a.kt)("p",null,"Convolution partitioning is done if the number of element convolutions is above this threshold."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public int ConvolutionPartitioningThreshold { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-12"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32"},"Int32"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelcomputeintervals"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelComputeIntervals")),(0,a.kt)("p",null,"If true, Interval.ComputeIntervals may use parallel implementation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelComputeIntervals { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-13"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"parallelcomputeintervalsthreshold"},(0,a.kt)("strong",{parentName:"h3"},"ParallelComputeIntervalsThreshold")),(0,a.kt)("p",null,"Interval.ComputeIntervals is done with parallel implementation if the number of elements is above this threshold."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public int ParallelComputeIntervalsThreshold { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-14"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32"},"Int32"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelinsertioncomputeintervals"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelInsertionComputeIntervals")),(0,a.kt)("p",null,"In parallel Interval.ComputeIntervals, do element-in-interval insertion in parallel too."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelInsertionComputeIntervals { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-15"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparalleldeconvolution"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelDeconvolution")),(0,a.kt)("p",null,"If true, long sequence convolutions are processed in parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelDeconvolution { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-16"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"deconvolutionparallelizationthreshold"},(0,a.kt)("strong",{parentName:"h3"},"DeconvolutionParallelizationThreshold")),(0,a.kt)("p",null,"Deconvolution parallelization is done if the number of element deconvolutions is above this threshold."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public int DeconvolutionParallelizationThreshold { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-17"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32"},"Int32"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelextend"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelExtend")),(0,a.kt)("p",null,"In Curve.Extend, compute extension sequences in parallel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelExtend { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-18"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelcomputeextensionsequences"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelComputeExtensionSequences")),(0,a.kt)("p",null,"In Curve.ComputeExtensionSequences, compute elements of the sequence in parallel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelComputeExtensionSequences { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-19"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"useparallelsortelements"},(0,a.kt)("strong",{parentName:"h3"},"UseParallelSortElements")),(0,a.kt)("p",null,"In Extensions.SortElements, sort the elements in parallel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseParallelSortElements { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-20"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"singlepassconvolution"},(0,a.kt)("strong",{parentName:"h3"},"SinglePassConvolution")),(0,a.kt)("p",null,"If true, when two Curves have the same slope the convolution is done in a single pass"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool SinglePassConvolution { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-21"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"userepresentationminimization"},(0,a.kt)("strong",{parentName:"h3"},"UseRepresentationMinimization")),(0,a.kt)("p",null,"If set, results of each operation are optimized towards minimal representation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseRepresentationMinimization { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-22"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"usesubadditiveconvolutionoptimizations"},(0,a.kt)("strong",{parentName:"h3"},"UseSubAdditiveConvolutionOptimizations")),(0,a.kt)("p",null,"If set, convolutions between sub-additive curves are optimized"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool UseSubAdditiveConvolutionOptimizations { get; set; }\n")),(0,a.kt)("h4",{id:"property-value-23"},"Property Value"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h2",{id:"constructors"},"Constructors"),(0,a.kt)("h3",{id:"computationsettings-1"},(0,a.kt)("strong",{parentName:"h3"},"ComputationSettings()")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public ComputationSettings()\n")),(0,a.kt)("h2",{id:"methods"},"Methods"),(0,a.kt)("h3",{id:"default"},(0,a.kt)("strong",{parentName:"h3"},"Default()")),(0,a.kt)("p",null,"Default settings"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static ComputationSettings Default()\n")),(0,a.kt)("h4",{id:"returns"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings"},"ComputationSettings"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"tostring"},(0,a.kt)("strong",{parentName:"h3"},"ToString()")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public string ToString()\n")),(0,a.kt)("h4",{id:"returns-1"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.string"},"String"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"gethashcode"},(0,a.kt)("strong",{parentName:"h3"},"GetHashCode()")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public int GetHashCode()\n")),(0,a.kt)("h4",{id:"returns-2"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.int32"},"Int32"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"equalsobject"},(0,a.kt)("strong",{parentName:"h3"},"Equals(Object)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool Equals(object obj)\n")),(0,a.kt)("h4",{id:"parameters"},"Parameters"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"obj")," ",(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.object"},"Object"),(0,a.kt)("br",null)),(0,a.kt)("h4",{id:"returns-3"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"equalscomputationsettings"},(0,a.kt)("strong",{parentName:"h3"},"Equals(ComputationSettings)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool Equals(ComputationSettings other)\n")),(0,a.kt)("h4",{id:"parameters-1"},"Parameters"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"other")," ",(0,a.kt)("a",{parentName:"p",href:"/docs/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings"},"ComputationSettings"),(0,a.kt)("br",null)),(0,a.kt)("h4",{id:"returns-4"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/api/system.boolean"},"Boolean"),(0,a.kt)("br",null)),(0,a.kt)("h3",{id:"clone"},(0,a.kt)("strong",{parentName:"h3"},"<","Clone",">","$()")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public ComputationSettings <Clone>$()\n")),(0,a.kt)("h4",{id:"returns-5"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/nancy/Unipi.Nancy.MinPlusAlgebra/ComputationSettings"},"ComputationSettings"),(0,a.kt)("br",null)))}c.isMDXComponent=!0}}]);